# SLO Enforcer

**Automatic guardrails. Zero manual intervention.**

SLO Enforcer continuously monitors your service level objectives and automatically takes corrective action when thresholds are breached—before users are impacted.

---

## Quick Example

```python
from openai import OpenAI

client = OpenAI(
    base_url="https://api.igrisinertial.com/v1",
    api_key="your-key"
)

# SLO Enforcer runs automatically
response = client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": "Hello"}]
)

# If p99 latency exceeds threshold, enforcer automatically:
# - Shifts traffic to faster providers
# - Adjusts retry logic
# - Updates Thompson Sampling weights
print(response.metadata)
# {
#   "slo_action": "traffic_shifted",
#   "reason": "p99_latency_breach",
#   "from_provider": "openai",
#   "to_provider": "anthropic"
# }
```

---

## What You Get

### Automatic Remediation

Real-time monitoring and action:

**Sub-Second Detection**: Identifies SLO breaches in under 500ms

**Automatic Action**: No manual intervention required

**Multi-Metric**: Monitors latency, errors, cost, and availability

**Audit Trail**: Complete log of all actions taken

### Monitored Metrics

**Latency SLOs:**
- P99 latency threshold
- P95 latency threshold
- Average response time

**Reliability SLOs:**
- Error rate percentage
- Availability percentage
- Success rate

**Cost SLOs:**
- Cost per request budget
- Monthly spend limits
- Provider cost efficiency

---

## How It Works

<details>
<summary><strong>1. Define SLOs</strong></summary>

Configure your service level objectives:

```bash
POST /v1/slo/config
{
  "latency": {
    "p99_ms": 500,
    "p95_ms": 300
  },
  "reliability": {
    "error_rate_max": 0.01,
    "availability_min": 0.999
  },
  "cost": {
    "max_cost_per_request_usd": 0.02,
    "monthly_budget_usd": 10000
  }
}
```

</details>

<details>
<summary><strong>2. Continuous Monitoring</strong></summary>

Enforcer scrapes Prometheus metrics every 10 seconds:

- P99/P95 latency from histogram metrics
- Error rates from counter metrics
- Cost data from billing tracker
- Availability from health checks

</details>

<details>
<summary><strong>3. Breach Detection</strong></summary>

When a threshold is exceeded:

- **Immediate evaluation** via Rust FFI
- **Root cause analysis** identifies failing component
- **Remediation plan** generated automatically
- **Action execution** begins within 500ms

</details>

<details>
<summary><strong>4. Automatic Actions</strong></summary>

Enforcer can take multiple remediation actions:

**Traffic Shifting:**
```
Action: Shift traffic from OpenAI to Anthropic
Reason: P99 latency breach (623ms > 500ms threshold)
Impact: Projected -35% latency improvement
```

**Circuit Breaking:**
```
Action: Open circuit breaker for provider "openai"
Reason: Error rate spike (3.2% > 1% threshold)
Duration: 5 minutes
```

**Rate Limiting:**
```
Action: Reduce request rate to 500 RPS
Reason: Cost overrun ($0.025 > $0.02 per request)
Duration: Until cost normalizes
```

**Provider Disabling:**
```
Action: Temporarily disable provider "google"
Reason: Availability drop (97.8% below 99.9% threshold)
Recovery: Automatic health check re-enable
```

</details>

---

## Configuration

### SLO Definitions

Define thresholds per metric:

```yaml
slo_config:
  latency:
    p99_ms: 500        # P99 latency must be under 500ms
    p95_ms: 300        # P95 latency must be under 300ms
    enabled: true

  reliability:
    error_rate_max: 0.01     # Max 1% error rate
    availability_min: 0.999  # Min 99.9% availability
    enabled: true

  cost:
    max_per_request: 0.02    # Max $0.02 per request
    daily_budget: 1000       # Max $1000/day
    enabled: true
```

### Action Policies

Control how aggressive remediation is:

```yaml
action_policies:
  traffic_shift:
    enabled: true
    cooldown: 5m          # Wait 5min between shifts

  circuit_breaker:
    enabled: true
    timeout: 30s
    max_retries: 3

  rate_limiting:
    enabled: true
    step_down_pct: 20     # Reduce by 20% increments

  provider_disable:
    enabled: false        # Require manual approval
    auto_reenable: true
```

### Notification Settings

Get alerted on SLO breaches:

```yaml
notifications:
  slack:
    enabled: true
    webhook_url: "https://hooks.slack.com/..."
    channels: ["#alerts"]

  email:
    enabled: true
    recipients: ["ops@company.com"]

  pagerduty:
    enabled: true
    integration_key: "..."
```

---

## Safety Guarantees

### Controlled Rollouts

Actions are applied gradually:

1. **Canary**: Test on 1% of traffic
2. **Validation**: Monitor for 1 minute
3. **Scale**: Increase to 10% → 50% → 100%
4. **Rollback**: Auto-revert if metrics worsen

### Circuit Breakers

Prevent runaway automation:

- **Max actions per hour**: Limit to 10 actions
- **Cooldown periods**: 5 minute minimum between actions
- **Manual override**: Emergency stop via dashboard
- **Audit log**: Complete history of all actions

### Human-in-the-Loop

Critical actions require approval:

- Provider permanent disabling
- Budget limit increases
- SLO threshold changes
- Multi-tenant actions

---

## Observability

### Dashboard View

Real-time SLO status:

```
SLO Enforcer Status
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Latency (P99):     387ms / 500ms  
Latency (P95):     234ms / 300ms  
Error Rate:        0.4% / 1%      
Availability:      99.97% / 99.9% 
Cost/Request:      $0.016 / $0.02 

Last 24h Actions:  3
└─ Traffic shifted (2x)
└─ Circuit opened (1x)
```

### Prometheus Metrics

Track enforcer behavior:

```
slo_breaches_total{metric="p99_latency"}
slo_actions_total{action="traffic_shift"}
slo_evaluation_duration_seconds
slo_current_value{metric="error_rate"}
slo_threshold_value{metric="p99_latency"}
```

### Audit Log

Every action is logged:

```json
{
  "timestamp": "2025-12-08T10:15:30Z",
  "action": "traffic_shift",
  "slo_type": "p99_latency",
  "current_value": 623,
  "threshold": 500,
  "target": "openai",
  "remediation": "shift_to_anthropic",
  "result": "success",
  "impact": {
    "latency_improvement_ms": -156,
    "cost_delta_pct": 3,
    "affected_requests": 1247
  }
}
```

---

## API Reference

### Get Current SLO Status

```bash
GET /v1/slo/status
```

**Response:**
```json
{
  "slos": {
    "p99_latency": {
      "current": 387,
      "threshold": 500,
      "status": "ok"
    },
    "error_rate": {
      "current": 0.004,
      "threshold": 0.01,
      "status": "ok"
    }
  },
  "recent_actions": 3,
  "last_breach": "2025-12-08T08:42:15Z"
}
```

### Get Action History

```bash
GET /v1/slo/actions?period=24h
```

**Response:**
```json
{
  "actions": [
    {
      "timestamp": "2025-12-08T10:15:30Z",
      "type": "traffic_shift",
      "reason": "p99_latency_breach",
      "result": "success"
    }
  ],
  "total": 3
}
```

### Update SLO Configuration

```bash
PUT /v1/slo/config
{
  "latency": {
    "p99_ms": 600
  }
}
```

---

## Integration with Rust FFI

SLO Enforcer uses Rust for performance-critical evaluation:

**Go Layer:**
- Scrapes Prometheus metrics every 10s
- Marshals data to JSON
- Calls Rust FFI via CGO

**Rust Layer:**
- Sub-millisecond evaluation (under 0.5ms p99)
- Determines breach severity
- Generates remediation actions
- Returns JSON response

**Benefits:**
- 10x faster than pure Go
- Zero GC pauses during evaluation
- Native Prometheus integration

---

## Best Practices

### Start Conservative

Begin with loose SLOs:

```yaml
# Start with relaxed thresholds
initial_config:
  p99_latency: 1000ms      # Loose threshold
  error_rate: 0.05         # 5% error tolerance
  actions_enabled: false   # Monitor only
```

### Gradually Tighten

Adjust based on baseline:

1. **Week 1**: Monitor without actions
2. **Week 2**: Enable non-destructive actions
3. **Week 3**: Enable traffic shifting
4. **Week 4**: Tighten thresholds to target SLOs

### Monitor Impact

Track action effectiveness:

- Did latency improve post-action?
- Were there unintended side effects?
- Is the action frequency appropriate?

---

## Availability

SLO Enforcer is included in:

- **Developer Tier**: Not available
- **Growth Tier**: Basic enforcement (latency, errors)
- **Scale Tier**: Full enforcement (latency, errors, cost, custom SLOs)

---

## Related Features

- [Observability](/docs/observability) - Metrics and monitoring
- [Shadow Mode](/docs/core-features/shadow-mode) - Safe testing
- [EscapeVector](/docs/core-features/escape-vector) - Offline failover

---

**Questions?** Email support@igrisinertial.com or join our [Discord](https://discord.gg/igris-overture)
